# Сессия 2

Рекомендации по Сессии 2, куски кода [смотри ниже](#Рекомендации-по-реализации)

## Разработка

### Список товаров

>Необходимо отобразить список товаров (в виде плитки), который должен соответствовать макету, предоставленному в ресурсах к заданию (пример в файле products_grid.png). Однако это не означает, что необходимо следовать макету в точности до пикселя - это всего лишь схема расположения элементов, на которую нужно ориентироваться при разработке пользовательского интерфейса.
>
>![](../img/products_grid.png)
>
>Каждый товар должен содержать следующую информацию: главное изображение, наименование, стоимость и отметку об активности (является товар на данный момент актуальным или нет).
Если товар не активен, то фон элемента должен быть серого цвета, в остальных случаях - белого.
>
>Около названия товара в круглых скобках должно отображаться количество дополнительных товаров, которые могут идти вместе с этим товаром.
>
>При наведении на карточку товара необходимо реализовать эффект изменения изображений как на примере (product_image_change_example.mov). Область с изображением товара делится на равные части с таким же количеством, как и количество изображений у товара. При перемещении мыши по горизонтали изображения должны меняться, а также иконки точек должны показывать текущую позицию в рамках списка изображений.
На странице со списком товаров необходимо добавить возможность поиска товаров по названию и описанию. Поиск должен работать в реальном времени (то есть без необходимости нажатия кнопки
“найти”).
>
>На странице со списком товаров необходимо добавить возможность фильтрации списка по производителю. Все производители из базы данных должны быть выведены в выпадающий список для
фильтрации. Первым элементом в выпадающем списке должен быть “Все элементы”, при выборе которого настройки фильтра сбрасываются. Фильтрация должна работать в реальном времени (то есть без необходимости нажатия кнопки “найти”).
>
>Функции фильтрации и поиска должны применяться совместно к итоговой выборке.
>
>Добавьте возможность отсортировать список по убыванию и возрастанию стоимости товара. Сортировка должна быть реализована отдельно (не с помощью стандартных функций элементов управления), потому что в дальнейшем планируется усложнение этого функционала путем добавления дополнительных условий.
>
>В нижней части окна необходимо показывать количество выведенных данных и общее количество записей в базе. Например, 230 из 450. В случае если данные в таблицу выводятся после фильтрации или
поиска, количество выведенных данных необходимо обновить исходя из размера выборки.
>
>Должна быть реализована возможность удаления выбранного товара. При этом должны соблюдаться следующие условия. Если у товара есть прикрепленные дополнительные товары, то информация по этим
прикрепленным товарам может быть удалена вместе с основным. Но если у товара есть информация о его продажах, то удаление товара из базы данных должно быть запрещено.

### Добавление/редактирование товара

>Необходимо добавить возможность редактирования данных существующего товара, а также добавление нового товара в новом окне - форме для добавления/редактирования товара.
>
>На форме должны быть предусмотрены следующие поля: идентификатор, наименование товара, стоимость, описание товара, главное изображение, производитель товара.
>
>При открытии формы для редактирования все поля выбранного объекта должны быть подгружены в соответствующие поля из базы данных.
>
>При добавлении нового товара идентификатор должен автоматически генерироваться, а поле для идентификатора отсутствует. В случае если пользователь редактирует товар, то поле с идентификатором
доступно только для чтения.
>
>Стоимость товара может включать сотые части, а также не может быть отрицательной.
>
>При изменении данных о товаре у пользователя должна быть возможность сделать товар неактивным или наоборот (поставить/снять соответствующую галочку). Это означает, что в предложениях дополнительных товаров он не будет показан администратору, но в списке товаров он должен быть.
>
>Пользователь может добавить/заменить главное изображение у товара. На экране должна показываться миниатюра выбранной фотографии. Размер фотографии не должен превышать 2 мегабайта.
Для того чтобы администратор случайно не изменял несколько товаров (тем более связанных), предусмотрите невозможность открытия более одного окна редактирования товара.
>
>После редактирования/добавления товара данные в окне списка товаров должны быть обновлены.

### Предложение дополнительных товаров

>В окне добавления/редактирования товара необходимо указывать связанные товары, чтобы администратор при работе с клиентом мог предложить товары, которые так или иначе связаны с покупкой. Для примера вспомните, как в одном популярном ресторане для детей, менеджер вам предлагает дополнительный пирожок или картошку фри к вашему заказу? Так вот они это делают, так как у них на экране появляется надпись (например, “предложить клиенту пирожок”) в зависимости от списка товаров, которые вы заказали.
>
>При открытии формы для редактирования ранее прикрепленные товары должны подгружаться из базы
данных.
>
>Для каждого прикрепленного товара должна выводиться миниатюра (главное изображение). При наведении на миниатюру в подсказке должны отображаться название и стоимость данного товара. По
клику можно перейти в окно добавления/редактирования товара со всей подробной информацией.
>
>Необходимо предусмотреть функционал для добавления определенных дополнительных товаров к выбранному (причем не только один, но и несколько). Имейте в виду, что нельзя добавить товар в
качестве дополнительного к самому себе (не пытайтесь нарушить покой вселенной), а также должен быть реализован запрет на прикрепление неактивных товаров.
>
>Предусмотрите также возможность удаления прикрепленных товаров из списка.
>
>Прикрепленные товары должны сохраняться в базе данных для каждого выбранного товара.

### История продаж товаров

>В окне списка товаров необходимо предусмотреть возможность перейти на окно для получения списка всех продаж этого товара.
На данном окне должна быть возможность посмотреть информацию о конкретном товаре, дате и времени продажи, а также количестве проданного товара.
>
>Записи должны быть по умолчанию отсортированы по дате и времени по убыванию.
>
>Необходимо предусмотреть фильтр по товарам. Данные для фильтрации в выпадающий список должны быть подгружены из БД. По умолчанию в выпадающем списке должен быть выбран товар, переход по которому был осуществлен на данное окно.

# Рекомендации по реализации

## Название приложения

В "Требованиях и рекомендациях" сказано, что наименование приложения должно ОБЯЗАТЕЛЬНО включать название компании заказчика, поэтому никаких "Demo", "doom" не должно быть:

![название приложения](../img/demo13.png)

>Называть лучше латиницей, хз как поведет себя система с кириллицей в названии

## Установка иконки

В контекстном меню **приложения** выбираете *свойства*

![свойства проекта](../img/demo14.png)

В первом же пункте "приложение" через "обзор" находите иконку (она есть в "общих ресурсах"). Студия автоматически скопирует файл иконки в корень проекта, руками его копировать не нужно.

![свойства проекта](../img/demo15.png)

## Цветовая схема и логотип

Это было в лекциях и многие это даже сделали, останавливаться не буду.

## Заголовки окон

Для главного окна можно написать название компании (*.xaml - Window - Title), для остальных по назначению окна. Например, если открываете окно со справочником товаров, то так и называейте "Справочник товаров"

```xml
<Window
    ...
    Title="Доеду Сам">
```

## Ограничение размера окна

Про это я тоже говорил, но многие не сделали... Добавляете к тегу **Window** атрибуты *MinHeight* и *MinWidth*. Размеры эти нужно подбирать по содержимому, чтобы не терялись кнопки и другие визуальные компоненты.

```xml
<Window
    MinHeight="400" MinWidth="700"
    Title="Доеду Сам" Height="450" Width="800">
```

## Список товаров

Из МРМТ **никто** не сделал интерфейс "плиткой", так что и вы не впадайте в ступор, а тупо рисуйте **DataGrid**, мы его проходили.

*"Каждый товар должен содержать следующую информацию: главное изображение, наименование, стоимость и отметку об активности"* - т.е. в DataGrid-e отображаете только эти поля таблицы товаров.

*Если товар не активен, то фон элемента должен быть серого цвета*

Можно также не рисовать навигатор со страницами, а сразу в главном окне вывести таблицу товаров (это, правда, будет нарушением логики, т.к. каждая сущность должна быть в своем файле)

Ниже как раз приведен до предела упрощенный код такого приложения который, тем не менее, рисует таблицу в нужном месте:

```xml
<Grid>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="150"/>
        <ColumnDefinition Width="1*"/>
    </Grid.ColumnDefinitions>

    <DataGrid Grid.Column="1" ItemsSource="{Binding MyProducts}"/>
</Grid>
```

```cs
public partial class MainWindow : Window
{
    private List<Products> _MyProducts;
    public List<Products> MyProducts
    {
        get
        {
            return _MyProducts;
        }
        set
        {
            _MyProducts = value;
        }
    }

    public MainWindow()
    {
        InitializeComponent();
        this.DataContext = this;
        MyProducts = Core.DB.Products.ToList();
    }
}
```

![](../img/demo16.png)

Это была программа минимум для тех, кому достаточно тройки и кто надеется набрать баллов в других сессиях.

## Продвинутый вариант

Читаем ТЗ и записываем требования:

* товар должен содержать следующую информацию
    * ~~главное изображение~~ (пока пропустим)
    * наименование (с количеством дополнительных товаров)
    * стоимость
    * отметку об активности
* поиск по названию в реальном времени
* фильтр по производителю в реальном времени
* ~~сортировка по полям~~ (это DataGrid делает сам)
* в нижней части окна нужно показывать сколько выведено и сколько всего товаров

>Показ количества дополнительных товаров требует выборки с группировкой, делать это в приложении моветон, это нужно делать в *представлении* (пока пропустим)

[Хабр. Отношения.](https://habr.com/ru/post/488054/)

https://code.tutsplus.com/ru/articles/sql-for-beginners-part-3-database-relationships--net-8561


Настраиваем отображаемые колонки. Нового для вас тут ничего нет, это было в лекциях - нужно тупо запомнить. Единственно, что у меня в таблице поле *Active* типа **int**, поэтому я его значение вычисляю геттером:

```xml
<DataGrid 
    Grid.Column="1" 
    ItemsSource="{Binding MyProducts}"
    AutoGenerateColumns="False">

    <!-- а это раскраска строк в зависимости от активности товара -->
    <DataGrid.RowStyle>
        <Style TargetType="DataGridRow">
            <Style.Triggers>
                <DataTrigger Binding="{Binding Active}" Value="0">
                    <Setter Property="Background" Value="LightGray"/>
                </DataTrigger>
            </Style.Triggers>
        </Style>
    </DataGrid.RowStyle>

    <DataGrid.Columns>
        <DataGridTextColumn 
            Header="Название"
            Binding="{Binding Name}"/>
        <DataGridTextColumn 
            Header="Цена" 
            Binding="{Binding Price}"/>
        <DataGridTextColumn 
            Header="Активен" 
            Binding="{Binding ActiveStr}"/>
    </DataGrid.Columns>
</DataGrid>
```

```cs
public partial class Products
{
    ...
    public int Active { get; set; }
    public string ActiveStr { 
        get {
            if (Active == 1) return "да";
            else return "нет";
        } 
    }
}
```

![datagrid с нужными колонками и раскраской](../img/demo17.png)